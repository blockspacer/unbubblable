<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Unbubblable</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index:100;
			}

		</style>
	</head>

	<body>
		<div id="info">Unbubblable</div>
		<div id="container"></div>

		<script src="js/vendor/three/build/three.js"></script>

		<script src="js/vendor/three/libs/stats.min.js"></script>
		<script src="js/vendor/Detector.js"></script>
		<script src='js/vendor/THREEx.KeyboardState.js'></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var renderer, scene, camera, stats;
			var objects = [];

			var meshMap;
			var meshCube;
			var meshChar;
			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

			var keyboard = new THREEx.KeyboardState();

			var scale = 16;

			var Character = {};
			Character.position = new THREE.Vector3(0, 0, scale/4);
			Character.angle = 0; //угол

//	var clock = new THREE.Clock();
//	var matrix = new THREE.Matrix4();
//	var period = 15;

			var camHeight = 14;

			init();
			animate();
			

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0x111111 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );

				camera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, scale*200 );

				scene = new THREE.Scene();

				//scene.fog = new THREE.Fog( 0x111111, 16*1500, 16*2000 );

				var textureMap = new THREE.TextureLoader().load( 'textures/atlas.png' );
				textureMap.magFilter = THREE.NearestFilter;
				textureMap.minFilter = THREE.NearestFilter;
				//THREE.NearestMipMapNearestFilter;
				//THREE.LinearFilter;
				//THREE.LinearMipMapLinearFilter;
				textureMap.flipY = false;
				textureMap.generateMipmaps = false;
				//textureMap.anisotropy = 4;
				//textureMap.anisotropy = renderer.getMaxAnisotropy();

				var atlasMap = new THREE.MeshBasicMaterial( { map: textureMap } );

				var atlas = {};
				atlas.Cols = 16;
				atlas.Rows = 16;
				atlas.TileSize = 32;
				atlas.Uoff = 1/atlas.Cols / (atlas.TileSize * 2 * 4);
				atlas.Voff = 1/atlas.Rows / (atlas.TileSize * 2 * 4);
				//atlas.Uoff = 0;
				//atlas.Voff = 0;
				atlas.Tiles = [];

				for (var i = 0; i < atlas.Cols*atlas.Rows; i++) {

					var v = Math.floor(i / atlas.Cols)
					var u = i - ( v * atlas.Cols)
				
					/*
						красный		0        1
									*---------*		зеленый
									|         |
									|    ^    |
									|         |
						синий   	*---------*		желтый
									3        2

						1: 3-0-2
						2: 0-1-2
					*/

					var tile = {};

					tile.UVs = [
						new THREE.Vector2(u/atlas.Cols+atlas.Uoff, (v+1)/atlas.Rows-atlas.Voff),
						new THREE.Vector2((u+1)/atlas.Cols-atlas.Uoff, (v+1)/atlas.Rows-atlas.Voff),
						new THREE.Vector2((u+1)/atlas.Cols-atlas.Uoff, v/atlas.Rows+atlas.Voff),
						new THREE.Vector2(u/atlas.Cols+atlas.Uoff, v/atlas.Rows+atlas.Voff)
					];

					tile.Faces = [];

					tile.Faces.push( [
						[ tile.UVs[3], tile.UVs[0], tile.UVs[2] ],
						[ tile.UVs[0], tile.UVs[1], tile.UVs[2] ] ] );

					tile.Faces.push( [
						[ tile.UVs[2], tile.UVs[3], tile.UVs[1] ],
						[ tile.UVs[3], tile.UVs[0], tile.UVs[1] ] ] );

					tile.Faces.push( [
						[ tile.UVs[1], tile.UVs[2], tile.UVs[0] ],
						[ tile.UVs[2], tile.UVs[3], tile.UVs[0] ] ] );

					tile.Faces.push( [
						[ tile.UVs[0], tile.UVs[1], tile.UVs[3] ],
						[ tile.UVs[1], tile.UVs[2], tile.UVs[3] ] ] );

					atlas.Tiles.push( tile );
				}

				// Map
				/*
				var geometryMap = new THREE.PlaneGeometry( scale*16, scale*16, 16, 16 );
				geometryMap.faceVertexUvs = [[]];
				for (var i = 0; i < 256; i++) {
					geometryMap.faceVertexUvs[0].push( atlas.Tiles[i].Faces[0][0] );
					geometryMap.faceVertexUvs[0].push( atlas.Tiles[i].Faces[0][1] );
				}
				*/

				var mapSize = 32;
				var br = [0,1,6,7,16,17,18,19,36,37];
				var geometryMap = new THREE.PlaneGeometry( scale*mapSize, scale*mapSize, mapSize, mapSize );
				geometryMap.faceVertexUvs = [[]];
				for (var i = 0; i < mapSize*mapSize; i++) {

					var s = Math.floor(Math.random() * (10));
					geometryMap.faceVertexUvs[0].push( atlas.Tiles[br[s]].Faces[0][0] );
					geometryMap.faceVertexUvs[0].push( atlas.Tiles[br[s]].Faces[0][1] );
				}


				meshMap = new THREE.Mesh( geometryMap, atlasMap );
				scene.add( meshMap );

				// Cube

//		var materials = [
//    		leftSide,        // Left side
//    		rightSide,       // Right side
//    		topSide,         // Top side
//    		bottomSide,      // Bottom side
//		    frontSide,       // Front side
//    		backSide         // Back side
//		];
//		var geometry = new THREE.CubeGeometry(100, 75, 8, 1, 1, 1, materials);
//		var someMesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial());

		var cubeFaceDir = [
    		1,		// Left side	ok
    		3,		// Right side	ok
    		2,		// Top side		ok
    		0,      // Bottom side	ok
		    0,		// Front side	ok
    		0		// Back side
		];

				var geometryCube = new THREE.BoxGeometry( scale, scale, scale );
				geometryCube.faceVertexUvs = [[]];
				for (var i = 0; i < 6; i++) {
					geometryCube.faceVertexUvs[0].push( atlas.Tiles[136].Faces[cubeFaceDir[i]][0] ); //231+i
					geometryCube.faceVertexUvs[0].push( atlas.Tiles[136].Faces[cubeFaceDir[i]][1] );
				}
				geometryCube.faceVertexUvs[0][4*2] = atlas.Tiles[137].Faces[0][0];
				geometryCube.faceVertexUvs[0][4*2+1] = atlas.Tiles[137].Faces[0][1];

				meshCube = new THREE.Mesh( geometryCube, atlasMap );
				meshCube.up = new THREE.Vector3( 0, 0, 1 );

				scene.add( meshCube );
				//meshCube.rotation.x = - 3.14 / 6;
				meshCube.position.x = scale/2;
				meshCube.position.y = scale/2;
				meshCube.position.z = scale/2;

				// Tiles
				/*
				var geometryTile = new THREE.PlaneGeometry( 2*scale*3, 2*scale*3, 3, 3 );
				geometryTile.faceVertexUvs = [[]];
				for (var i = 0; i < 9; i++) {
					geometryTile.faceVertexUvs[0].push( atlas.Tiles[177].Faces[0][0] );
					geometryTile.faceVertexUvs[0].push( atlas.Tiles[177].Faces[0][1] );
				}
				
				meshTile = new THREE.Mesh( geometryTile, atlasMap );
				meshTile.position.set( scale*8, scale*4, scale );
				scene.add( meshTile );
				*/

				// Char
				var geometryChar = new THREE.BoxGeometry( scale/2, scale/2, scale/2 );
				meshChar = new THREE.Mesh( geometryChar, atlasMap );
				geometryChar.faceVertexUvs = [[]];
				for (var i = 0; i < 6; i++) {
					geometryChar.faceVertexUvs[0].push( atlas.Tiles[217].Faces[0][0] );
					geometryChar.faceVertexUvs[0].push( atlas.Tiles[217].Faces[0][1] );
				}
				scene.add( meshChar );
				meshChar.position.z = scale/4;

/*
var axisHelper = new THREE.AxisHelper( 50 );
scene.add( axisHelper );

edges = new THREE.FaceNormalsHelper( meshCube, 2, 0x00ff00, 1 );
scene.add( edges );

// вектор направления куба
var matrix = new THREE.Matrix4();
matrix.extractRotation( meshCube.matrix );
var dir = new THREE.Vector3( 0, 0, 1 );
dir = matrix.multiplyVector3( dir );
var origin = meshCube.position.clone();
var length = 2*scale;
var hex = 0xffff00;
var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
scene.add( arrowHelper );
*/

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				//
				var debug = document.getElementById( 'info' );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );

				render();
				stats.update();
			}

			function render() {

				var time = Date.now() * 0.001;

				if( keyboard.pressed("Q") ) {
					Character.angle += 0.05;
				}

				if( keyboard.pressed("E") ) {
					Character.angle -= 0.05;
				}

				// направление взгляда вперед
				var charQuat = new THREE.Quaternion();
				charQuat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Character.angle);
				//var charQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Character.angle);

				// вектор движения вперед
				var charDirection = new THREE.Vector3( 0, 1, 0 );
				charDirection.applyQuaternion( charQuat );

				// направление взгляда направо
				var charRightQuat = new THREE.Quaternion();
				charRightQuat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Character.angle - Math.PI/2);

				// вектор движения направо 
				var charRightDirection = new THREE.Vector3( 0, 1, 0 );
				charRightDirection.applyQuaternion( charRightQuat );

				var speed = 1.5;

				var charMotion = new THREE.Vector3();

				if( keyboard.pressed("D") ) {
					charMotion.add(charRightDirection);
				}

				if( keyboard.pressed("A") ) {
					charMotion.sub(charRightDirection);
				}

				if( keyboard.pressed("W") ) {
					charMotion.add(charDirection);
				}

				if( keyboard.pressed("S") ) {
					charMotion.sub(charDirection);
				}


				if( keyboard.pressed("pageup") ) {
					camHeight -= 0.1;
				}

				if( keyboard.pressed("pagedown") ) {
					camHeight += 0.1;
				}


				charMotion.normalize();
				charMotion.multiplyScalar( speed );
				Character.position.add( charMotion );

				//meshChar.position = Character.position;
				meshChar.position.x = Character.position.x;
				meshChar.position.y = Character.position.y;

// крутим чара
meshChar.rotation.setFromQuaternion( charQuat, 'XYZ' );
//meshChar.rotateOnAxis( new THREE.Vector3(-1,0,0), time*0.5);

// крутим камеру
camera.rotation.setFromQuaternion( charQuat, 'XYZ' );
camera.rotateOnAxis( new THREE.Vector3(1,0,0), Math.PI/6);


				//var camDistance = -7*scale;
				var camDistance = camHeight*scale/-2;
				
				// перемещаем камеру
				var camPos = new THREE.Vector3();
				camPos.addVectors( Character.position, charDirection.multiplyScalar( camDistance ) );
				camera.position.set( camPos.x, camPos.y, camHeight*scale );

				//console.log(camera.position);

				renderer.render( scene, camera );

// статистика рендера
//				const { render, memory } = renderer.info
//				stats.textContent = `
//				calls: ${render.calls}
//				faces: ${render.faces}
//				vertices: ${render.vertices}
//				geometries: ${memory.geometries}`
			}

	</script>

</body>

</html>
